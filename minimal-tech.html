<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>@alexcleac - Minimal Tech</title>
    <link href="/res/stylesheet.css" rel="stylesheet">
    <link rel="preload" href="/res/alexcleac.png">
  </head>
  <body>
    <header>
      <a href="/">
        <img class="ava ava-small" src="/res/alexcleac.png">
        <h1 class="name">@alexcleac</h1>
      </a>
    </header>
    <content>
      <h1>Minimal Tech</h1>
      <h2>Description</h2>
      <p>
        It is a small project of mine about possibility to live in modern life
        while using the most of things software gives to us. The general idea is
        about using simpler or/and older software and try getting most of it,
        including all the requirements of modern tech.
      </p>
      <p>
        This project is more like a web log, rather than a blog page of some
        kind. I will sometimes post random small things about what I've
        discovered and/or tried, and what is my experience about it.
      </p>
      <p>
        <a href="/minimal-tech.rss">Subscribe via RSS</a>
      </p>
      <!-- @call scripts/new_post.py -->
      <log-entry id="28-may-2020">
        <h2>26 May, 2020 - <a href="#28-may-2020">Automating stuff your own way</a></h2>
        <p>
          Recently, I've made some automations of the way I am using my laptop.  I've made
          pretty basic ones: automatic placement specific windows at specific tags in
          AwesomeWM, slight simplifications in Vim, automations to this blog and a bit
          more. And abandoned my own laptop for some time, because I had lots of things to
          do for work (which I do for now using MacBook, which is pretty bad in my
          opinion).  Yesterday, I've logged in to my own laptop, and found, how I
          undervalued those simple automations are. Thanks to easiness on resources of my
          window manager and overall tooling I am using, I have got everything running
          almost instantly. My computer started slower than all the programs I need and
          use: terminal emulator, DeadBeef, Transmission, Syncthing client and some small
          utility apps. All of this has happened without me even noticing or thinking
          about it.
        </p>
        <p>
          Basically, this is the thing, why we have computers in first place: to simplify our
          quality of life by automating stuff here and there. And we've made those things way
          harder to achieve by decreasing entry level to computing. They say that almost every
          person can now do simple automations using Shortcuts app on
          iPhone<sup><a href="#28-may-2020-link-1">[1]</a></sup>. But are they using it? Only
          power users are, while all the other people don't. This "simpler" interface did not
          decrease entry level to automation, because people still need to learn how to
          use it, while they make a lot harder to maintain and develop more complex logic
          (if compared to good old code). So it became less accessible than the way of
          automation, available to Linux and *BSD, because, you have to learn the
          automation using every single platform you have: on Web it is IFTTT, on iPhone
          it is Shortcuts, etc... Every single "user friendly" platform has it's
          block-scheme-like UI to configure chains and no other way of doing
          it. Is it actually <b>the best</b> way? I think not!
        </p>
        <p>
          I have automated different parts of my workflows using different languages. I use
          Bash for some small scripts that automate my shell, like
          roj.sh<sup><a href="#28-may-2020-link-2">[2]</a></sup>
          (for managing tmux sessions for projects), Python for some slightly more complex
          automations, like rw.py<sup><a href="#28-may-2020-link-3">[3]</a></sup>
          (for simplifying updating RSS feeds and writing this blog) and lua for window
          manager automations (because I like using AwesomeWM and am too lazy to learn
          anything else). But basically people are not required to do it the way I do.
          Someone will automate everything in Emacs using Lisp. Other will use Python or
          JavaScript for literally everything, or use Haskell, Erlang and C all together.
          The choice is <b>yours</b> to make, not developer's or marketologist's.
        </p>
        <p>
          You don't have to be a programmer to tell computer what to do. You can mostly
          copy-and-paste different code snippets to make things working the way you like. Even
          if you do it this way, it is more accessible and easier way than learning how to do it
          with every single possible block-scheme-alike UI to tell computers what to do. Because
          why otherwise all programming industry still write code and not move blocks?
        </p>
        Links:
        <ul>
          <li id="28-may-2020-link-1">
            [1]
            <a href="https://apps.apple.com/us/app/shortcuts/id915249334">Shortcuts app on AppStore</a></li>
          <li id="28-may-2020-link-2">
            [2]
            <a href="https://git.sr.ht/~alexcleac/dotfiles/tree/master/bin/roj.sh">roj.sh</a>
            ‚Äî script in my dotfiles for managing tmux sessions based on projects
            directory basis
          </li>
          <li id="28-may-2020-link-3">
            [3]
            <a href="https://git.sr.ht/~alexcleac/dotfiles/tree/master/bin/rw.py">rw.py</a>
            ‚Äî script that implements some elements of static site
            generators without their bloat
          </li>
        </ul>
      </log-entry>
      <log-entry id="01-may-2020">
        <h2>01 May, 2020 - <a href="#01-may-2020">Laptopless</a></h2>
        <p>
          Some time ago, when I have landed a new job, I've got really decent laptop
          (thinkpad e7-something) there, so I didn't actually need to bring my personal
          laptop to be able to gain mobility at work. So my personal laptop has settled
          on the table, and haven't moved much since that time, partly because it has a
          bit dead battery (and I can't change it to any better one, already spent $200
          bucks for bad replacements I can't refund üòîÔ∏è).
        </p>
        <p>
          So, I've found it is pretty fun to have my home computer be stationary, because
          I stopped having it everywhere I am going. And I've found out that actually I
          have no need in carrying one more computer in my bag besides a "smart" phone.
          Even the "smart" phone is actually more than I need, but I am fine with that
          I have.
        </p>
        <p>
          What am I trying to tell by this? Stop carrying your laptop everywhere you
          go! Because then you will have less time being able to do anything with it
          and start looking for tools that can actually make your life easier. And this
          is what Minimal Tech about.
        </p>
      </log-entry>
      <log-entry id="20-jan-2020">
        <h2>20 January, 2020 - <a href="#20-jan-2020">Call it Minimal Tech!</a></h2>
        <p>
	  Now I've encountered an issue regarding my journey into Minimal Tech.
	  I can't clearly describe, what do I mean by "Minimal Tech". So, I
	  would like to make this clear to everybody, and my in the first
	  place.
        </p>
        <p>
	  By telling "Minimal Tech" I mean those tools that can give you most
	  possibilities by requiring from you the least resources as possible.
	  This includes computer resources (like CPU clock speed and amount of
	  RAM), person resources (time, mind possibilities) and money.
        </p>
        <p>
	  For someone, this statement is a bit incompatible with things I've
	  been writing about before. It is not. Because most of tools you learn
	  that work the UNIX-way are meant to last. Most of the tools created
	  to follow those concepts are able to last for longer, because they
	  were created to integrate with each other. So you can adapt new
	  possibilities and tools without abandoning previous ones, but instead
	  use them together, which gives you less requirement to learn how to
	  use computers over and over again. And they still fast, because, duh,
	  nobody rewrites them in JavaScript, so you can save on buying new
	  expensive computer (you can even use RaspberryPi 3, which is really
	  cheap nowadays!) or even just use the phone.
        </p>
        <p>
	  Moreover, investing time in more minimal tooling is actually better
	  than investing it into some "App", because you will actually learn
	  once, and will no longer need to learn how to achieve basic tasks,
	  because the ways of achieving them don't change as much as it change
	  on the world of "normal people". For example, knowing vim by heart
	  allows me almost as productive with vim, as with an IDE (without
	  completion or tagging or any plugins more complicated than NERDTree
	  and vim-surround).
        </p>
        <p>
	  This path can feel a bit hard for some time. Because when you switch
	  from the "easy to use" Windows, or OSx or ________________ (place
	  your "easy-to-use" operating system here), you have to find the way
	  of doing things <i>your</i> way. There will be nobody to dictate to
	  do things in any way like those, listed above, do. There will be a
	  many to propose, but only damned trolls and morons will dictate.
	  Minimal Tech give you the rod, not the fish. It is your task to get
	  the fish.
        </p>
        <p>
	  Stick with Minimal Tech. You will like it a lot, when someone is
	  suffering from the next piece of software being deprecated and dead.
	  You may call it differently, but you should or already know that at
	  the end, you will be the winner.
        </p>
      </log-entry>
      <log-entry id="02-jan-2020">
        <h2>02 January, 2020 - <a href="#02-jan-2020">Happy New Year and Merry Christmas üéÑ</a></h2>
        <p>
          It was the 31th of December, when those words were written. Today is already the second of December (not long enough in my timezone though), but I still those words to be published.
        </p>
        <p>
          I'd like to tell that this year was particularly good for me. It started with opening a whole new realm of professional growth via learning Scala and Functional Programming paradigm. It was followed by now stack of tasks and interesting people I wish I kept. Started a blog which I still keep writing after several months (many drafts, not enough courage to do the editing work). Started learning foreign languages. Joined new great team right before the New Year. And I am back on the path of constant development, thanks to everyone around me.
        </p>
        <p>
          I thank my beloved wife and family, Orchideous, the Fediverse community and all the awesome people I've encountered this year. I'd like to thank you for you reading these words, because this means you follow my path in one way or another (RSS/Atom is still WIP, but close enough ;) ).
        </p>
        <p>
          The 2020 is going to be tough and interesting for me. I probably will write some Elixir. Will get a Masters Degree in Computer Science. I want to continue writing this blog and continue my journey into functional programming. Meet new awesome people. Not loose people I already now, even only on internet.
        </p>
        <p>
          I wish you to gain everything you wish to gain in the next year. But not more than you really need. Because the more you have, the harder it is to find, what do you want to achieve next.
        </p>
        <p>
          Happy New 2020 Year!
        </p>
        <p>
          P.S. BTW, now I use Arch
        </p>
      </log-entry>
      <log-entry id="15-oct-2019">
        <h2>15 October, 2019 - <a href="#15-oct-2019">Unplug from Hive Mind</a></h2>
        <p>
          Recently I did an interesting thing I did never did before. I disabled
          internet connectivity for some time.
        </p>
        <p>
          It may sound strange for those of you, who did live without internet
          for a while, but I am millenial - I had Internet at home for half of my
          concious life. And it felt strange for several minutes for me (however,
          not exactly, because I am generally always ready for Internet
          blackout). But this one was pretty different and curious. I've found
          out several things, that were pretty new to me.
        </p>
        <p>
          First thing that I've found out: the laptop battery life increased
          drastically. That one is pretty obvious, because when you disable
          Wi-Fi, nothing tries to anything via radio waves, so the battery
          becomes better. But I actually had no clue, how much does that make
          difference. It gave me about 2-3 additional hours of battery life. This
          was achieved, when I closed web browser, slack and telegram, because
          they are generally useless without internet connection.
        </p>
        <p>
          Second, I started making more things available offline. Like, some
          youtube videos I want to watch later, or just keep them around to watch
          sometimes. Music. Email. Books. These posts are being offline as well
          (actually they are written in my VimWiki base, but later about it).
        </p>
        <p>
          And, thanks to most of things being offline, the third one - my
          laptop actually has gotten faster these moments. Because everything is
          local, the slowest thing to access content is an SSD and not network
          bandwith. Everything has gotten faster and smoother as ever before.
        </p>
        <p>
          Bonus one and actually unexpected for me. I started producing more
          things: more blog posts has been written lately, more curious and
          interesting things happening around me happening. I started playing
          guitar, which, I thought has gotten abandoned completely. Just because
          I've unplugged from hive mind.
        </p>
        <p>
          So, don't mind trying to detach yourself, it may make your life
          actually a lot better.
        </p>
      </log-entry>
      <log-entry id="07-oct-2019">
        <h2>7 October, 2019 - <a href="#07-oct-2019">In speed of light</a></h2>
	<p>
	  For some time, I've abandonned the project, mainly because I was
	  wandering around different tech, that promised to solve my tasks
	  better. I've switched to Gnome, then to Windows for several weeks and
	  then I've moved back to Gnome and back to Minimal Tech. It feels that
	  I just can't decide, which to stick with, even for me... But, I think
	  now I've sticked finally, because I really feel at home now.
	  Everything fast, smooth and very convenient. And if I want something
	  specific, I can spend some time and make it.
	</p>
	<p>
	  I'd like to mention the thing I've been very happy with,
	  after I made the journey I've mentioned above. The speed. When I've
	  switched to Gnome, things became slightly slower, but it was ok for, I
	  just wanted to be like others and do things in GUI. Thus, I was still
	  using mutt and other terminal utilities, when graphical ones broke.
	  Then I switched to Windows, and things became <b>even slower</b>, but
	  still, I didn't care about that. It was "beautiful". But after two weeks
	  I've installed linux back, and
	  it was an experience of switching to a sport car. So fast, so
	  predictible, so homomorphic. That felt great. But at some point, small
	  issues started coming around: slight lag, when I started an IDE, steam
	  not working under wayland and the decrease of overall smoothness of
	  Gnome on X11. So, I've installed awesomewm, like before.
	</p>
	<p>
	  Things became waay faster than even on gnome! 99% of tasks are now
	  done in the speed of light, sometimes it feels like the machine has
	  found some more horsepower. And with switching some things to offline,
	  moving to more terminal applications, I can run 900 MHz on CPU and
	  don't feel much difference compared to speed on 2.3 GHz, except the
	  extended battery life and less heat produced.
	</p>
	<p>
	  I think, every moment is a good moment to make a consideration to
	  switch to Minimal Tech. It is <b>good</b> here, but sometimes you have
	  to learn how to use computer from scratch. But I don't think this
	  should be issue for anyone :)
	</p>
      </log-entry>
      <log-entry id="22-july-2019">
        <h2>22 July, 2019 - <a href="#22-july-2019">Too minimal</a></h2>
        <p>
          Today I was configuring snippets system to write scala more productive
          way, and found out one fun thing: it is possible to get too deep
          into minimal tech things to achieve same productivity level as for
          more powerful technologies.
        </p>
        <p>
          As I am a professional software engineer, my work includes writing
          lots and lots of code. Sometimes it is hugely boilerplated one,
          copied from one place, pasted at another with slight editing. Why
          copied? Because it is easier to make new mistakes while rewriting
          same boilerplate. So, to decrease such copy-pasting, I've decided to
          use snippets system in vim. I decided to use UltiSnips<sup><a href="#2-july-2019-link-1">1</a></sup>
          because it allows to script all the things the way I want, including
          shell scripting, python, etc.
        </p>
        <p>
          However, things got harder, when I started writing snippets to make
          exhaustive snippets to do pattern-matching on different types for
          scala. I understood, that it is not that easy to write them, having
          only the <i>text</i>. I have to infer types one of next ways:
        </p>
        <ol type="1">
          <li>Find out the type of object myself and use matching snippet</li>
          <li>
            Write a runtime guesser of type and use python scripting
            capability to achieve what I need
          </li>
        </ol>
        <p>
          The first one will take more effort in process of coding. The second
          one will become a burden in the RAM and make my setup <i>not that
          minimal</i>. You see? It is possible to get too minimal. Code is not
          just a simple text, it is highly structured text with pretty specific
          concepts and links through it that are important to make development
          process faster.
        </p>
        <p>
          I probably will end up writing my own type parser (or integrating
          with metals project for scala), because it is a pretty interesting
          task and it will highly optimize my workflow. But this will make my
          vim editing setup for scala less of editor but more of IDE.
        </p>
        <p>
          Getting minimal is good. But it is possible to easily get
          <i>too minimal</i> to be productive.
        </p>
      </log-entry>
      <log-entry id="2-july-2019">
        <h2>2 July, 2019 - <a href="#2-july-2019">@bitwarden/cli && mail in the terminal (part 2)</a></h2>
        <p>
          Some time ago I have written<sup><a href="#2-july-2019-link-1">1</a>,<a href="#2-july-2019-link-2">2</a></sup>,
          how did I did use biwarden CLI interface to throw passwords to mutt
          email client. There was one single thing that did bother me a lot for
          some time: since I use several IMAP sources, I had to type the
          password of keystore <i>every single time I switched source</i>. That
          is not very convenient, because it slowed workflow down a lot. So,
          I've managed to find a way to make this thing work better way (at
          least it works faster).
        </p>
        <p>
          First, I'd like to mention the previous setup. I had such a line in
          every source:<br\>
        </p>
        <pre class="code">set imap_pass = `export BW_SESSION=$(bw unlock --raw) &amp;&amp; bw get password <i>uuid</i>`</pre><br\>
        <p>
          This is the reason, why I did need to type password every single
          time. So've I looked at several ways of how could I solve this one.
        </p>
        <p>
          There were several assumtions on how could I make this work. Mutt
          itself allows to execute commands, store variables and very much
          more, so my first assumtion was to try unlocking session only once
          and reusing to get password for every source when switching to it.
          But it didn't work, because backtick expansion does not use mutt
          variables. So I've searched the Internet a bit and found out a fun
          thing: mutt does execute the output of backtick expansion by default.
        </p>
        <p>
          So I came up with simple script that simply generates the set of
          variables with passwords. Here it is:
        </p>
<pre class="code">
#!/usr/bin/env python3
# gen_pwds.py
import subprocess, getpass
ITEMS = [ ('key', 'uuid') ]

def get_command_result(*command):
    return subprocess.run(command, capture_output=True).stdout.strip().decode('ascii')

keystore_password = getpass.getpass('Enter the keystore password: ')
key = get_command_result('bw', 'unlock', keystore_password, '--raw')
for name, uuid in ITEMS:
    password = get_command_result('bw', '--session', key, 'get', 'password', uuid)
    print(f'set my_{name}_password={password}', end=';')
</pre class="code">
        <p>
          Then, I put a simple line of code into basic muttrc:
          <b>`gen_pwds.py`</b> and simply use generated variables. Easy, but a
          bit insecure, in fact. But works for me as well.
        </p>
        Links:
        <ul>
          <li id="2-july-2019-link-1">
            <a href="#5-june-2019">[1] Mail in the terminal (part 1) - @alexcleac</a>
          </li>
          <li id="2-july-2019-link-2">
            <a href="#14-june-2019">[2] @bitwarden/cli - @alexcleac</a>
          </li>
        </ul>
      </log-entry>
      <log-entry id="25-june-2019">
        <h2>25 June, 2019 - <a href="#25-june-2019">A week only on Android Linux</a></h2>
        <p>
          If you are following my mastodon account, you may know that for some
          strange reason, cooling system of my laptop has got dead due to a
          short circuit in cooling power supply. Now I've got my laptop back
          and I would like to share some thoughts that I've encountered due to
          this period.
        </p>
        <p>
          1. As you can see from my previous post, I made a small experiment on an
          Android tablet and installed there some part of my cli toolkit using
          a Termux terminal emulator. Everything felt pretty nice, but there is
          one thing that still bothers me. For unknown reason, every terminal
          application I ran increased the power consuming. Five minutes session
          of reading and sending emails with mutt and vim could take about 10%
          of battery. To compare, same session of using K9<a></a>
          mail client about 1-2%. That's strange.
        </p>
        <p>
          2. Physical keyboard support is strange. It feels almost like good
          old linux. But not exactly. I couldn't change input language without
          changing keyboard (until I install AnySoftKeyboard, which is
          literally awesome, developers made an awesome job making hardware
          keyboard support). I've got sometimes strange issues with cyrillic
          keyboard, when some keys were moved to different place (it's the
          keyboard type issue, but I couldn't find how to fix it). Despite
          these issues - it worked well.
        </p>
        <p>
          3. Node applications are borked. After using a bit slower CPU, I've
          realized that even python applications worked way faster than the
          javascript ones. And this including the fact that v8 is JIT compiled
          platform. Still can't understand, what's wrong with it.
        </p>
        <p>
          And despite all the small issues, it is possible to overcome them and
          simply use the system. So it <i>does</i> pay off to move some
          activities to the terminal. Because when you get into situation,
          where you simply can't run a plain old linux, you can still find a
          way around to use the same applications stack without learning it
          from scratch. You simply configure the environment from your dotfiles
          and just run.
        </p>
      </log-entry>
      <log-entry id="14-june-2019">
        <h2>14 June, 2019 - <a href="#14-june-2019">@bitwarden/cli</a></h2>
        <p>
          Yesterday I've found a new fun way interesting way to install use
          passwords I store in Bitwarden<sup><a href="#14-june-2019-link-1">1</a></sup>.
          There is a package on npm called <b>@bitwarden/cli</b>, which gives
          you a command line interface to access and use passwords. And it can
          be pretty useful in fact (I used to think that you won't ever need a
          cli interface for password manager, it's just so inconvenient - until
          yesterday).
        </p>
        <p>
          Currently, I am using it with mutt email client. I've configured it
          such way, so I can list inbox without having a password in a
          plaintext. Sure, there is a pass<sup><a href="#14-june-2019-link-2">2</a></sup>,
          but I want to sync it the modern way, have too different ecosystem
          devices to sync files (if you actually know a good way of it, feel
          free to share it with me, look at social media<sup><a href="#14-june-2019-link-3">3</a></sup>
          section of front page).
        </p>
        <p>
          However, it is not that trivial, how can you use the bitwarden for
          mutt. You see, after you run <b>bw unlock</b> and type your password,
          it just prints further instructions on how can you use the session
          key to access the vault. You can store the key in environment
          variable <b>BW_SESSION</b> or pass as a cli argument. Both ways are
          pretty inconvenient in mutt scenario, because you have to run
          command, then copy session key, then paste it, then run another one
          command. But, when you run <b>bw unlock --raw</b>, you typed
          password, it just prints the session key. So you can pass it directly
          into env variable or command line argument.
        </p>
        <p>
          And it works nice, I've tested it both on my Android tablet and a
          laptop I use on daily basis. It works great (however, it is a bit
          slow due to it works on node.js, but what apps have no downsides
          today?).
        </p>
        Links:
        <ul>
          <li id="14-june-2019-link-1"><a href="https://bitwarden.com/">
            [1] bitwarden - open source password management
          </a></li>
          <li id="14-june-2019-link-2"><a href="https://www.passwordstore.org/">
            [2] Pass: the standard unix password manager
          </a></li>
          <li id="14-june-2019-link-3"><a href="https://cleac.me/#social">
            [3] How to contact me :D
          </a></li>
        </ul>
      </log-entry>
      <log-entry id="10-june-2019">
        <h2>10 June, 2019 - <a href="#10-june-2019">Tile this window!</a></h2>
        <p>
          Have you ever noticed that most of users use window manager in a
          single mode: a full screen window mode? People spend all the time
          running this mode. The maximum advanced mode I've seen is a two
          windows split. And these people tell me that tiling managers are to
          hard for them. So... I'd like to speak about tiling window managers.
        </p>
        <p>
          If you will try any tiling window manager, you will get several
          simple things out of box, without any need for you to do anything.
          First, most of them are pretty lightweight, compared to others.
          Second, your windows will tile <i>by default</i>. So, you won't need
          to move window anywhere, or click anything to get window maximized,
          or tiled (if there are more then one window). Third, most of them
          have window decorations disabled, so more space will be saved for
          content. Fourth, you will be just like a magic wizard, that somehow
          makes all the awesome things fast and easy.
        </p>
        <p>
          Personally I run AwesomeWM<sup><a href="#10-june-2019-link-1">1</a></sup>.
          It's light fast, simple and is scriptable in Lua. So I can make it
          reflect any workflow I have: a timer integrated in top bar, a
          floating "picture-in-picture" kimulated window, change image every
          minute, run specific applications on specific tags and display
          several tags in the same time. I <i>love</i> this power for myself.
        </p>
        <p>
          However, awesomewm itself is pretty simple out of box and requires
          from you some effortand coding to start using it. So you would
          definitely try i3wm<sup><a href="#10-june-2019-link-2">2</a></sup>
          or sway<sup><a href="#10-june-2019-link-3">3</a></sup>, if you want
          to have wayland. They both have lots of batteries included, are fast,
          simple and do not require from you any programming skills at all.
        </p>
        <p>
          So, if you haven't tried a tiling window manager yet, give it a try.
          Just give it some more time, and after some time running it you
          probably will feel awkward when running DEs like Gnome, KDE and
          other.
        </p>
        Links:
        <ul>
          <li id="10-june-2019-link-1"><a href="https://awesomewm.org/">
              [1] awesome window manager
          </a></li>
          <li id="10-june-2019-link-2"><a href="https://i3wm.org/">
              [2] i3 - an improved tiling wm
          </a></li>
          <li id="10-june-2019-link-3"><a href="https://swaywm.org/">
              [3] sway - a tiling wayland compositor
          </a></li>
        </ul>
      </log-entry>
      <log-entr id="5-june-2019"y>
        <h2>5 June, 2019 - <a href="#5-june-2019">Mail in the terminal (part 1)</a></h2>
        <p>
          I have been wanting to try out mutt for several times now. It's just
          too much of people speaking about it's awesomeness, so I couldn't
          resist. I've tried running it several times, but without any
          success... Now I am sure I won't leave it. Somewhat sure *laughing*
        </p>
        <p>
          I should be clear here. mutt is noway a minimal application, but when
          things come to handling e-mails, you simply can't keep things
          minimal. If it has at least some use-base, it already should already
          support different protocols, have possibility to group messages
          somehow, store draft, etc. So, <u>mutt is not minimal</u>. But
          compared to other email-clients, it <b>is</b> simple.
        </p>
        <p>
          About the entry into mutt. It's a bit harder to enter this
          application than other email clients, because it has default
          configuration that reads all the emails from local pool. And, the
          thing that bothers a lot: the first step is the hardest, because it
          takes time and lots of documentation to read to understand that this
          code:
        </p>
        <pre class="code">set folder = imaps://login@server:123</pre>
        <p>
          does specify the
          target, where do you want to read emails from. It's a bit
          counterintuitive for newcomers. But I've figured this out, and, I
          think, this should be mentioned more explicit.
        </p>
        <p>
          But, after figuring this out, things are pretty simple and easy to
          use. However, I have some things in my todo list to figure out,
          like mailing lists support and some other.
        </p>
      </log-entry>
      <log-entry id="22-may-2019">
        <h2>22 May, 2019 - <a href="#22-may-2019">Music in the Terminal</a></h2>
        <p>
          Mostly I listen to my music using the terminal music player called
          <a href="https://cmus.github.io/">cmus</a>. It is really a great
          music player, which allows me easily and very fast index my music
          collection and play pretty any song. I just put it inside my tmux
          session and just use it. Very fast, very lightweight and very
          reliable.
        </p>
        <p>
          Moreover, it is possible to integrate with it easily using the
          <a href="https://github.com/cmus/cmus/blob/master/Doc/cmus-remote.txt">cmus-remote</a>.
          I think, KDE uses this api and is able to integrate with cmus, so you
          will be able to use the "Media" widget to control your music. And all
          this in minimal design, fast and very light. However, sometimes it
          badly accepts unicode, but generally everything is ok.
        </p>
      </log-entry>
      <log-entry id="18-may-2019">
        <h2>18 May, 2019 - <a href="#18-may-2019">Getting Br√ºtal</a></h2>
        <p>
          This is a first entry inside this log. First, I've decided to start
          tracking all the interesting and fun things I find about simple and
          sometimes obscure technologies. Why public? Because I can! Also,
          because there is not much people around me use those simpler tech,
          while in fact they can do not less things, but more optimal/fast from
          many perspectives.
        </p>
        <p>
          Well, for last year I am an active user of mastodon social network.
          It's fediverse, and blah-blah-blah. I would like to mention one
          project, I've got myself lately: it is
          <a href="https://brutaldon.online">brutaldon project</a>. It is
          a brutalistic (br√ºtal) interface for masto. Although I know about it
          for some time, I didn't use it, because didn't get the reason why
          should I do it (the default interface is column-based, fast enough
          and pretty optimized). However, on phone it is easier to use
          brutaldon. Also, brutaldon looks better in small window than the
          original frontend version. That makes it less distractive for me to
          use.
        </p>
        <p>
          Although there are things I don't like much about brutaldon. First is that
          it is written in python. Then over high load it will be pretty slow,
          so it is better to host it yourself instead of using the original
          version. Second thing is that to mention someone correctly, you have
          to know the nickname exactly (so when I want to mention someone I
          don't remember the instance of, I start the original web version,
          write a post and close it afterwards).
        </p>
        <p>
          Despite issues, I totally recommend at least to try using it for
          several days. It can fit your way!
        </p>
      </log-entry>
    </content>
    <footer>
      <p>
        All content of this site is authored by me, alexcleac. All opinions and
        projects are mine and do not relate to my job if other is not mentioned.
      </p>
      <p>
        If you liked the content or have some commentaries on it, feel free to
        write or mention me at any <a href="/index.html#social">social
        media</a> you can find me.
      </p>
      (c) @alexcleac 2019-2023
    </footer>
  </body>
</html>
